<?php

namespace Repositories\UserRepository;

use App\Models\Payment;
use App\Models\User;
use App\Repositories\UserRepository;
use App\Services\PaymentService\Impaya\ImpayaPaymentService;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Carbon;
use Tests\TestCase;

class UserRepositorySuccessfulPaymentsTest extends TestCase
{
    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        \Artisan::call('db:truncate');
    }

    protected function createUserWithPayment(int $planId, string $paymentType, string $paymentStatus, Carbon $createdAt, array $userAttributes = [])
    {
        // Создаем пользователя с указанными атрибутами
        $user = User::factory()->create(array_merge([
            'payment_plan' => $planId,
            'is_active' => true,
            'is_disabled' => false,
        ], $userAttributes));

        // Создаем платеж с заданными параметрами для данного пользователя
        Payment::factory()->create([
            'user_id' => $user->id,
            'type' => $paymentType,
            'status' => $paymentStatus,
            'service' => Payment::SERVICE_IMPAYA,
            'rebill_id' => '123',
            'created_at' => $createdAt,
        ]);

        return $user;
    }

    public function test_it_returns_only_users_with_successful_payments()
    {
        $planId = 1;
        $monthlyIntervalInMinutes = config('payments_miazaim.monthly.interval_in_minutes');

        // Пользователь с успешным рекуррентным платежом более месяца назад (по заданному интервалу)
        $userWithSuccessfulPaymentMoreThanMonthAgo = $this->createUserWithPayment(
            $planId,
            Payment::TYPE_RECURRENT,
            Payment::STATUS_PAYED,
            Carbon::now()->subMinutes($monthlyIntervalInMinutes + 60) // чуть больше месяца назад
        );

        // Пользователь с успешным рекуррентным платежом менее месяца назад (по заданному интервалу)
        $userWithSuccessfulPaymentLessThanMonthAgo = $this->createUserWithPayment(
            $planId,
            Payment::TYPE_RECURRENT,
            Payment::STATUS_PAYED,
            Carbon::now()->subMinutes($monthlyIntervalInMinutes - 60) // чуть меньше месяца назад
        );

        // Пользователь с неуспешным рекуррентным платежом неделю назад
        $userWithFailedPaymentLessThanMonthAgo = $this->createUserWithPayment(
            $planId,
            Payment::TYPE_RECURRENT,
            Payment::STATUS_DECLINED,
            Carbon::now()->subWeek()
        );

        // Пользователь с неуспешным рекуррентным платежом более месяца назад (по заданному интервалу)
        $userWithFailedPaymentMoreThanMonthAgo = $this->createUserWithPayment(
            $planId,
            Payment::TYPE_RECURRENT,
            Payment::STATUS_DECLINED,
            Carbon::now()->subMinutes($monthlyIntervalInMinutes + 60)
        );

        // Пользователь без платежей, тоже у него должно быть списание
        $userWithoutPayments = User::factory()->create([
            'payment_plan' => $planId,
            'is_active' => true,
            'is_disabled' => false,
        ]);

        $usersForTest = collect([
            $userWithSuccessfulPaymentMoreThanMonthAgo,

            // Эти пользователи не должны попасть в выборку
            $userWithSuccessfulPaymentLessThanMonthAgo,
            $userWithFailedPaymentMoreThanMonthAgo,
            $userWithFailedPaymentLessThanMonthAgo,
            $userWithoutPayments,
        ]);

        $usersForTest->each(function ($user) {
            Payment::factory()->create([
                'user_id' => $user->id,
                'type' => Payment::TYPE_DEFAULT,
                'status' => Payment::STATUS_CARD_ADDED,
                'service' => Payment::SERVICE_IMPAYA,
                'rebill_id' => '123',
                'created_at' => Carbon::now(),
            ]);
        });

        // Шаг 1: Проверка базового запроса
        $repository = new UserRepository();
        $initialUsers = $repository->getUsersForRecurrentCharge($planId)->get();

        $this->assertCount($usersForTest->count(), $initialUsers);
        $usersForTest->each(function ($user) use ($initialUsers) {
            $this->assertTrue($initialUsers->contains($user), "User {$user->id} is missing in initial query.");
        });

        // Шаг 2: Проверка финального фильтра
        $filteredUsers = $repository->getUsersWithSuccessfulPayments($planId)->get();

        $this->assertCount(2, $filteredUsers);
        $this->assertTrue($filteredUsers->contains($userWithSuccessfulPaymentMoreThanMonthAgo));
        $this->assertTrue($filteredUsers->contains($userWithoutPayments));


        $this->assertFalse($filteredUsers->contains($userWithSuccessfulPaymentLessThanMonthAgo));
        $this->assertFalse($filteredUsers->contains($userWithFailedPaymentMoreThanMonthAgo));
        $this->assertFalse($filteredUsers->contains($userWithFailedPaymentLessThanMonthAgo));
    }
}
